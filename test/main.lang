game_of_life :: mod;

array :: mod;

core :: mod;
test_global_copy_and_access :: mod;

test_globals :: mod;
test_impl_blocks :: mod;
test_mut :: mod;
test_new_import :: mod;
test_proc_access :: mod;
test_procedure_type :: mod;
test_struct_self_storage :: mod;
test_switch :: mod;

auto_cast_test :: () {
	var :u32 = 0;
	var2 :s64 = 0;
	var2 = cast(s64, var);
}

glob_test :: () {

}

glob_test :: (arg: bool, arg: ssize) {

}

Geometry :: enum s32 {
	Line = 10;
	Triange = 5;
	Line = 100;
}

NoFielder :: struct {
	x: s32;
	x: f32;
}

Box :: struct {
	topolody: Geometry;
	pos: Vec2;
}

Vec2 :: struct {
	x: f64;
	y: f32;
	zi: s32;
}

v2 :: struct {
	x: f32;
	y: f32;
}

ivec2 :: struct {
	x: s32;
	y: s32;
}

CellType :: enum {
	Grass = 0;
	VV = 0;
	Water = (20 << 4 * 9) | (5 >> 2) - 69;
	Rock = (20 << 4 * 9) | (5 >> 2) - 69;
}

Cell :: struct {
	pos: ivec2;
	type: CellType;
}

multi_array_test :: () {
	var : [2][3]s32;
	var[1][2] = 5;
}

array_test :: () {
	multi_array_test();
	
	var : [2]s32;
	

	var[0] = 5;
	var[1] = var[0];
	second := var;
	
}

test_new_switch :: () -> s32 {
	
	array_test();
	
	var := 3;
	
	return var;
}

test_size :: () -> NoFielder {
	print("cell size: %llu \n", sizeof(Cell));
	print("no fielder size: %llu \n ", sizeof(NoFielder));
	v := NoFielder.{ 5 };
	
	print("\\\n");
	
	return v;
}

nested_struct_init_test :: () {

}

Type :: struct {
	x: u64;
}

struct_init :: () {
	
	c : Cell;
	c.pos = .{ 2, 4 };
	c.type = CellType::Grass;
}


fcast_check :: () {
	x: f32 = ((4));
	y := 1;
	x = y;
	y = x;
	x = x + 400;
}


icast_check :: () {
	x := 25 - (4 * 2) / 6 + 1;
	y := -0;
	z := 1 << 3;
	y :u16 = 500;
}


Baz :: enum u8 {
	V = -1;
	B = 25;
	C = 300;
}

array_initializers :: () {
	var : [2]i32 = { 1, 2 };
	var2 := [2]i32{ 1, 2 };
	
	arr1 : [2]i32;
	arr2 : [2]i32;
	arr1 = arr2;
	
	var3 :[2][3]i32 = { {2, 4, 5}, {3, 6, 7} };
	var4 : = [2][3]i32{ {2, 4, 5}, {3, 6, 7} };
}

bug_repro :: () -> i32 {
	fff := [2]ivec2{ .{2, 3}, .{4, 5} };
	return fff[1].y;
}

VecNoDefaults :: struct {
	x: f32;
	y: i32;
}

Vec22 :: struct {
	x: f64 = 22;
	y: f64 = 259594;
	baz: [2]Baazzz;
	biz: VecOne;
	bizarr: [2]VecOne;
}

Baazzz :: enum {
	Fish = 1;
	Boom = 2;
}

VecOne :: struct {
	pos: i32 = 50;
	vv: ComplexStruct;
}

ComplexStruct :: struct {
	x: i32 = 10;
}

SomeStruct :: struct {
	c: ComplexStruct;
}

Bom :: SomeStruct.{ .{ 50 }};
GArray :: [2][3]i32{ {11,21,31}, {11,21,31} };

main :: () -> i32 {
	char_lit := 32;
	vvv: Vec22;
	g : [5]Baazzz;
	v : [2][3]Vec22;
	print("default init test: x = %f, y = %f \n", v[1][2].x, v[1][2].y);
	v2 : VecNoDefaults;

	fff := [3]ivec2{.{2, 3}, .{4, 5}, .{6, 7}};
	test_var := fff[1].y;
	return test_var;
	
	print("1 y expext 5 : %d \n", test_var);
	
	print("0: ivec2: %d , %d \n", fff[0].x, fff[0].y);
	print("1: ivec2: %d , %d \n", fff[1].x, fff[1].y);
	print("2: ivec2: %d , %d \n", fff[2].x, fff[2].y);
	
	no_sizer := test_size();
	array_initializers();
	defer {}
	
	print("Custom lang hype!\n");
	print("New switch result: %d\n", test_new_switch());
	print("Board stuff: \n");

	var : [2]i32;
	var[0] = 69;
	var_ptr := *var;
	print("Num from array pointer: %d \n", var_ptr[0]);
	
	board : life::Board;
	life::board_set(*board, .{2, 3}, true);
	life::board_set(*board, .{4, 6}, true);
	life::board_print(*board);
	
	some_enum : Enum = .First + 2;
	MOD::MOD::Assos::call();
	
	board.cells = {
	{true, true, false, true, false, true, true, true},
	{true, false, true, true, true, true, false, true},
	{false, false, true, true, true, true, true, true},
	{true, true, false, true, true, false, true, true},
	{true, true, true, true, true, true, true, true},
	{false, true, true, true, false, true, true, true},
	{true, true, true, true, true, true, true, true},
	{true, true, false, true, true, true, true, true}
	};
	
	life::board_print(*board);
	
	glob_access::test();
	
	return 0;
	
	var : array::Array_i32;
	array::init(*var, 8);
	defer { array::deinit(*var); }
	
	v: Vec2;
	v.x = 4;
	v.zi = 100;
	
	box: Box;
	defer { box.pos.zi = 40; } 
	box.pos = v;
	box.pos.zi = 16;
	
	return box.pos.zi / 4;
	
	x := print("Custom lang hype!\n");
	y := print("Hellope.\n");
	z := print("Number and percent: % % %d", 69);
	y := print(3, 3, 4);
	return 0;
	
	return switch_test();
}
