//#prelude
import core:runtime.{assert}

//#entry "field_struct"
CONST_STRUCT = Example.{ x: 1, y: 2, inner: .{ z: 3, w: 4 } };

proc test_field_struct() void {
    let value = CONST_STRUCT;
    assert(value.x == 1);
    assert(value.y == 2);
    assert(value.inner.z == 3);
    assert(value.inner.w == 4);

    //single auto-deref
    let ref = &value;
    assert(ref.x == 1);
    assert(ref.y == 2);
    assert(ref.inner.z == 3);
    assert(ref.inner.w == 4);

    //constant
    assert(CONST_STRUCT.x == 1);
    assert(CONST_STRUCT.y == 2);
    assert(CONST_STRUCT.inner.z == 3);
    assert(CONST_STRUCT.inner.w == 4);
}

struct Example {
    x: s32,
    y: s32,
    inner: Inner,
}
struct Inner {
    z: s32,
    w: s32,
}

//#entry "field_string"
CONST_STRING = "example";

proc test_field_string() void {
    let value = CONST_STRING;
    assert(value.len == 7);

    //single auto-deref
    let ref = &value;
    assert(ref.len == 7);

    //constant
    assert(CONST_STRING.len == 7);
}

//#entry "field_slice"
proc test_field_slice() void {
    let empty: []s32 = [][..];
    let array: []s32 = [1, 2, 3][..];
    assert(empty.len == 0);
    assert(array.len == 3);

    //single auto-deref
    let empty_ref = &empty;
    let array_ref = &array;
    assert(empty_ref.len == 0);
    assert(array_ref.len == 3);

    //pointer field equality
    assert(empty.ptr == empty_ref.ptr);
    assert(array.ptr == array_ref.ptr);
}

//#entry "field_array"
CONST_EMPTY: [0]s32 = [];
CONST_ARRAY = [1, 2, 3];

proc test_field_array() void {
    let empty: [0]s32 = [];
    let array = [1, 2, 3];
    assert(empty.len == 0);
    assert(array.len == 3);

    //single auto-deref
    let empty_ref = &empty;
    let array_ref = &array;
    assert(empty_ref.len == 0);
    assert(array_ref.len == 3);

    //constant
    assert(CONST_EMPTY.len == 0);
    assert(CONST_ARRAY.len == 3);
}
